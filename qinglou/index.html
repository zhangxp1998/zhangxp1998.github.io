<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã€Šé’æ¥¼ã€‹æœºåˆ¶å°ç¨‹åº</title>
    <!-- å¼•å…¥ Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        [v-cloak] { display: none; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 font-sans min-h-screen pb-10">
    <div id="app" v-cloak class="max-w-7xl mx-auto pt-4 px-2 md:pt-6 md:px-4 space-y-4 md:space-y-6">
        
        <!-- Header -->
        <header class="bg-white shadow-md rounded-lg p-5 flex flex-col md:flex-row justify-between items-center gap-4 border-t-4 border-indigo-600">
            <div>
                <h1 class="text-2xl font-bold text-slate-800 flex items-center gap-2">
                    <span>ğŸ“œ</span> ã€Šé’æ¥¼ã€‹æœºåˆ¶å°ç¨‹åº
                </h1>
                <p class="text-sm text-slate-500 mt-1">è®°å½•å®è—ã€æœè¯è·¯çº¿ã€æš—æ€é˜²å…·ä¸ç»“ç®—</p>
            </div>
            <div class="flex flex-wrap gap-2 mt-4 md:mt-0 w-full md:w-auto justify-start">
                <button @click="currentTab = 'setup'" :class="{'bg-indigo-600 text-white': currentTab==='setup', 'bg-slate-100 text-slate-700 hover:bg-slate-200': currentTab!=='setup'}" class="flex-1 md:flex-none px-3 py-2 rounded-md font-medium transition-colors text-sm">âš™ï¸ è®¾ç½®</button>
                <button @click="currentTab = 'treasures'" :class="{'bg-indigo-600 text-white': currentTab==='treasures', 'bg-slate-100 text-slate-700 hover:bg-slate-200': currentTab!=='treasures'}" class="flex-1 md:flex-none px-3 py-2 rounded-md font-medium transition-colors text-sm">ğŸ’ å®è—</button>
                <button @click="currentTab = 'rounds'" :class="{'bg-indigo-600 text-white': currentTab==='rounds', 'bg-slate-100 text-slate-700 hover:bg-slate-200': currentTab!=='rounds'}" class="flex-1 md:flex-none px-3 py-2 rounded-md font-medium transition-colors text-sm">âš”ï¸ è½®æ¬¡</button>
                <button @click="currentTab = 'dashboard'" :class="{'bg-indigo-600 text-white': currentTab==='dashboard', 'bg-slate-100 text-slate-700 hover:bg-slate-200': currentTab!=='dashboard'}" class="flex-1 md:flex-none px-3 py-2 rounded-md font-medium transition-colors text-sm">ğŸ“Š æ€»è§ˆ</button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="bg-white shadow-md rounded-lg p-6 min-h-[600px] border border-slate-200">
            
            <!-- Tab: Setup -->
            <transition name="fade" mode="out-in">
                <div v-if="currentTab === 'setup'" key="setup" class="space-y-8">
                    <h2 class="text-xl font-bold border-b pb-2 text-indigo-700">åŸºç¡€è®¾ç½®</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <!-- è§’è‰²ç®¡ç† -->
                        <div class="space-y-4">
                            <h3 class="text-lg font-semibold flex items-center gap-2">ğŸ‘¥ è§’è‰²åˆ—è¡¨</h3>
                            <div class="flex gap-2">
                                <input v-model="newCharacterName" @keyup.enter="addCharacter" type="text" placeholder="è¾“å…¥è§’è‰²åç§°" class="flex-1 border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <button @click="addCharacter" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">æ·»åŠ </button>
                            </div>
                            <ul class="space-y-2">
                                <li v-for="(char, index) in characters" :key="char.id" class="flex justify-between items-center bg-slate-50 p-3 rounded border">
                                    <span class="font-medium">{{ char.name }}</span>
                                    <button @click="removeCharacter(index)" class="text-red-500 hover:text-red-700 text-sm">åˆ é™¤</button>
                                </li>
                            </ul>
                            <p v-if="characters.length === 0" class="text-slate-400 text-sm text-center py-4">æš‚æ— è§’è‰²ï¼Œè¯·æ·»åŠ </p>
                        </div>

                        <!-- åœ°ç‚¹ç®¡ç† -->
                        <div class="space-y-4">
                            <h3 class="text-lg font-semibold flex items-center gap-2">ğŸ“ ç‰©å“æœç´¢</h3>
                            <div class="flex gap-2">
                                <input v-model="newLocationName" @keyup.enter="addLocation" type="text" placeholder="è¾“å…¥åœ°ç‚¹åç§°" class="flex-1 border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <button @click="addLocation" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">æ·»åŠ </button>
                            </div>
                            <ul class="space-y-2">
                                <li v-for="(loc, index) in locations" :key="index" class="flex justify-between items-center bg-slate-50 p-3 rounded border">
                                    <span class="font-medium">{{ loc }}</span>
                                    <button @click="removeLocation(index)" class="text-red-500 hover:text-red-700 text-sm">åˆ é™¤</button>
                                </li>
                            </ul>
                            <p v-if="locations.length === 0" class="text-slate-400 text-sm text-center py-4">æš‚æ— åœ°ç‚¹ï¼Œè¯·æ·»åŠ </p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Treasures -->
                <div v-else-if="currentTab === 'treasures'" key="treasures" class="space-y-6">
                    <h2 class="text-xl font-bold border-b pb-2 text-indigo-700 flex justify-between items-center">
                        <span>ğŸ’ å®è—ä½ç½®è®°å½•</span>
                        <span class="text-sm font-normal text-slate-500">è®°å½•å¼€å±€å„åœ°ç‚¹éšè—äº†å“ªäº›å®ç‰©/é˜²å…·</span>
                    </h2>

                    <div v-if="locations.length === 0" class="text-center py-10 text-slate-500">
                        è¯·å…ˆåœ¨â€œåŸºç¡€è®¾ç½®â€ä¸­æ·»åŠ ç‰©å“æœç´¢ã€‚
                    </div>

                    <div v-else class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div v-for="loc in locations" :key="loc" class="border rounded-lg p-4 bg-slate-50 shadow-sm">
                            <h3 class="font-bold text-lg mb-3 text-slate-800 border-b pb-1">{{ loc }}</h3>
                            <div class="space-y-3">
                                <div class="flex items-center gap-2">
                                    <span class="font-medium text-slate-600 w-8">ä¸Š:</span>
                                    <input v-model="treasures[loc].up" type="text" placeholder="ç©º" class="flex-1 border rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                    <button @click="treasures[loc].up = ''" class="text-red-500 hover:text-red-700 text-xl leading-none" title="æ¸…ç©º">Ã—</button>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span class="font-medium text-slate-600 w-8">ä¸‹:</span>
                                    <input v-model="treasures[loc].down" type="text" placeholder="ç©º" class="flex-1 border rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                    <button @click="treasures[loc].down = ''" class="text-red-500 hover:text-red-700 text-xl leading-none" title="æ¸…ç©º">Ã—</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Rounds -->
                <div v-else-if="currentTab === 'rounds'" key="rounds" class="space-y-6">
                    <div class="flex justify-between items-center border-b pb-2">
                        <h2 class="text-xl font-bold text-indigo-700">âš”ï¸ è½®æ¬¡é¢æ¿</h2>
                        <div class="space-x-2">
                            <span class="font-bold text-lg mr-4">å½“å‰è½®æ¬¡: ç¬¬ {{ currentRoundNumber }} è½®</span>
                            <button @click="prevRound" :disabled="currentRoundNumber <= 1" class="px-3 py-1 bg-slate-200 rounded disabled:opacity-50">ä¸Šä¸€è½®</button>
                            <button @click="nextRound" class="px-3 py-1 bg-indigo-600 text-white rounded hover:bg-indigo-700">ä¸‹ä¸€è½® / æ–°å¢</button>
                        </div>
                    </div>

                    <div v-if="characters.length === 0" class="text-center py-10 text-slate-500">
                        è¯·å…ˆåœ¨â€œåŸºç¡€è®¾ç½®â€ä¸­æ·»åŠ è§’è‰²ã€‚
                    </div>
                    <div v-else class="space-y-8">
                        
                        <!-- æœè¯è®°å½• -->
                        <div class="bg-indigo-50 p-3 md:p-5 rounded-lg border border-indigo-100">
                            <h3 class="font-bold text-lg mb-4 text-indigo-800 flex items-center gap-2">ğŸ” æœè¯é˜¶æ®µè®°å½•</h3>
                            
                            <!-- ç§»åŠ¨ç«¯å¡ç‰‡è§†å›¾ & PCç«¯è¡¨æ ¼è§†å›¾èåˆ -->
                            <div class="grid grid-cols-1 gap-4">
                                <div v-for="char in characters" :key="char.id" 
                                     class="bg-white p-4 rounded shadow-sm border"
                                     :class="{'bg-red-50 border-red-200': isDeadBeforeCurrentRound(char)}">
                                     
                                    <div class="font-bold text-lg mb-3 flex items-center gap-2 border-b pb-2">
                                        <span>{{ char.name }}</span>
                                        <span v-if="isDeadBeforeCurrentRound(char)" class="text-xs bg-red-100 text-red-600 px-2 py-0.5 rounded font-normal">å·²æ­»äº¡</span>
                                    </div>
                                    
                                    <!-- æœç´¢åŠ¨ä½œ 1 -->
                                    <div class="grid grid-cols-1 md:grid-cols-12 gap-3 mb-2 items-center">
                                        <div class="md:col-span-4">
                                            <label class="block text-xs text-slate-500 mb-1 md:hidden">ç‰©å“æœç´¢</label>
                                            <select v-model="currentRoundData.searches[char.id].location" @change="onSearchLocationChange(char.id, 1)" :disabled="isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- æœªæœç´¢ --</option>
                                                <optgroup v-for="loc in locations" :key="loc" :label="loc">
                                                    <option :value="loc + ' - ä¸Š'">{{ loc }} - ä¸Š ({{ getAvailableItemText(loc + ' - ä¸Š', char.id, 1) }})</option>
                                                    <option :value="loc + ' - ä¸‹'">{{ loc }} - ä¸‹ ({{ getAvailableItemText(loc + ' - ä¸‹', char.id, 1) }})</option>
                                                </optgroup>
                                            </select>
                                        </div>
                                        <div class="md:col-span-5">
                                            <label class="block text-xs text-slate-500 mb-1 md:hidden">è·å¾—ç‰©å“ (é€—å·åˆ†éš”)</label>
                                            <input v-model="currentRoundData.searches[char.id].items" :disabled="isDeadBeforeCurrentRound(char)" type="text" placeholder="ä¾‹å¦‚: æ¯’è¯, é“¶ç¥¨" class="w-full border rounded px-2 py-2 disabled:bg-slate-100 focus:outline-none focus:ring-1 focus:ring-indigo-500 text-sm">
                                        </div>
                                        <div class="md:col-span-3 flex md:justify-center items-center gap-2">
                                            <label class="block text-xs text-slate-500 md:hidden">æ‰€éœ€é“¶ä¸¤:</label>
                                            <span class="text-sm text-amber-600 font-bold">{{ getItemCostText(currentRoundData.searches[char.id].items) }}</span>
                                        </div>
                                    </div>
                                    
                                    <!-- æœç´¢åŠ¨ä½œ 2 (å¦‚æœæœ‰æŠ€èƒ½) -->
                                    <div v-if="char.maxSearches > 1" class="grid grid-cols-1 md:grid-cols-12 gap-3 items-center border-t pt-2 mt-2 border-dashed">
                                        <div class="md:col-span-4">
                                            <select v-model="currentRoundData.searches[char.id].location2" @change="onSearchLocationChange(char.id, 2)" :disabled="isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- æœªæœç´¢ (2) --</option>
                                                <optgroup v-for="loc in locations" :key="loc" :label="loc">
                                                    <option :value="loc + ' - ä¸Š'">{{ loc }} - ä¸Š ({{ getAvailableItemText(loc + ' - ä¸Š', char.id, 2) }})</option>
                                                    <option :value="loc + ' - ä¸‹'">{{ loc }} - ä¸‹ ({{ getAvailableItemText(loc + ' - ä¸‹', char.id, 2) }})</option>
                                                </optgroup>
                                            </select>
                                        </div>
                                        <div class="md:col-span-5">
                                            <input v-model="currentRoundData.searches[char.id].items2" :disabled="isDeadBeforeCurrentRound(char)" type="text" placeholder="è·å¾—ç‰©å“ (2)" class="w-full border rounded px-2 py-2 disabled:bg-slate-100 focus:outline-none focus:ring-1 focus:ring-indigo-500 text-sm">
                                        </div>
                                        <div class="md:col-span-3 flex md:justify-center items-center gap-2">
                                            <label class="block text-xs text-slate-500 md:hidden">æ‰€éœ€é“¶ä¸¤:</label>
                                            <span class="text-sm text-amber-600 font-bold">{{ getItemCostText(currentRoundData.searches[char.id].items2) }}</span>
                                        </div>
                                    </div>
                                    
                                </div>
                            </div>
                        </div>

                        <!-- æš—æ€ä¸ç»“ç®— -->
                        <div class="bg-red-50 p-3 md:p-5 rounded-lg border border-red-100">
                            <h3 class="font-bold text-lg mb-4 text-red-800 flex items-center gap-2">ğŸ—¡ï¸ æš—æ€ä¸é˜²å…·ç»“ç®—</h3>
                            
                            <!-- ç§»åŠ¨ç«¯å¡ç‰‡è§†å›¾ & PCç«¯è¡¨æ ¼è§†å›¾èåˆ -->
                            <div class="grid grid-cols-1 gap-4 mb-4">
                                <div v-for="char in characters" :key="char.id" 
                                     class="bg-white p-4 rounded shadow-sm border"
                                     :class="{'bg-slate-50 opacity-60': isDeadBeforeCurrentRound(char)}">
                                     
                                    <div class="font-bold text-lg mb-3 border-b pb-2 text-slate-800">{{ char.name }} <span class="text-xs font-normal text-slate-500 ml-2">è¡ŒåŠ¨é˜¶æ®µ</span></div>

                                    <!-- æš—æ€åŠ¨ä½œ 1 -->
                                    <div class="grid grid-cols-2 md:grid-cols-12 gap-3 items-end">
                                        <div class="col-span-2 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">æš—æ€ç›®æ ‡</label>
                                            <select v-model="currentRoundData.assassinations[char.id].target" :disabled="isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- æ— åŠ¨ä½œ --</option>
                                                <option v-for="target in characters.filter(c => c.id !== char.id)" :key="target.id" :value="target.id">
                                                    {{ target.name }} {{ isDeadBeforeCurrentRound(target) ? '(å°¸ä½“)' : '' }}
                                                </option>
                                            </select>
                                        </div>
                                        <div class="col-span-2 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">ä½¿ç”¨æ­¦å™¨</label>
                                            <select v-model="currentRoundData.assassinations[char.id].weapon" :disabled="!currentRoundData.assassinations[char.id].target || isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- é€‰æ‹©æ­¦å™¨ --</option>
                                                <option v-for="item in allFoundWeapons" :key="item" :value="item" :disabled="!isWeaponAvailable(item, char.id)">
                                                    {{ item }} {{ !isWeaponAvailable(item, char.id) ? '(å·²è¢«ä»–äººä½¿ç”¨)' : '' }}
                                                </option>
                                            </select>
                                        </div>
                                        <div class="col-span-1 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">ç›®æ ‡é˜²å…·</label>
                                            <select v-if="currentRoundData.assassinations[char.id].target" v-model="currentRoundData.assassinations[char.id].targetArmor" class="w-full border rounded px-1 py-2 bg-white text-sm">
                                                <option value="">-- æ— é˜²å…· --</option>
                                                <optgroup label="å…æ­»é˜²å…·">
                                                    <option v-for="armor in allFoundArmors.lifeSaving" :key="armor" :value="armor" :disabled="!isArmorAvailable(armor, char.id, 1)">
                                                        {{ armor }} {{ !isArmorAvailable(armor, char.id, 1) ? '(å·²ç”¨)' : '' }}
                                                    </option>
                                                </optgroup>
                                                <optgroup label="é˜²ä¼¤é˜²å…·">
                                                    <option v-for="armor in allFoundArmors.damagePreventing" :key="armor" :value="armor" :disabled="!isArmorAvailable(armor, char.id, 1)">
                                                        {{ armor }} {{ !isArmorAvailable(armor, char.id, 1) ? '(å·²ç”¨)' : '' }}
                                                    </option>
                                                </optgroup>
                                            </select>
                                            <div v-else class="h-9 flex items-center text-slate-400 text-sm px-2">-</div>
                                        </div>
                                        <div class="col-span-1 md:col-span-3 flex justify-end md:justify-center items-center h-9">
                                            <span v-if="currentRoundData.assassinations[char.id].target && currentRoundData.assassinations[char.id].weapon">
                                                <span v-if="!checkAssassinationResult(currentRoundData.assassinations[char.id].weapon, currentRoundData.assassinations[char.id].targetArmor)" class="text-blue-600 font-bold bg-blue-50 px-3 py-1 rounded">ğŸ›¡ï¸ é˜²å¾¡</span>
                                                <span v-else class="text-red-600 font-bold bg-red-50 px-3 py-1 rounded">ğŸ’€ å‡»æ€</span>
                                            </span>
                                        </div>
                                    </div>

                                    <!-- æš—æ€åŠ¨ä½œ 2 (å¦‚æœæœ‰æŠ€èƒ½) -->
                                    <div v-if="char.maxAssassinations > 1" class="grid grid-cols-2 md:grid-cols-12 gap-3 items-end border-t border-dashed mt-4 pt-4">
                                        <div class="col-span-2 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">æš—æ€ç›®æ ‡ (2)</label>
                                            <select v-model="currentRoundData.assassinations[char.id].target2" :disabled="isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- æ— åŠ¨ä½œ --</option>
                                                <option v-for="target in characters.filter(c => c.id !== char.id && c.id !== currentRoundData.assassinations[char.id].target)" :key="target.id" :value="target.id">
                                                    {{ target.name }} {{ isDeadBeforeCurrentRound(target) ? '(å°¸ä½“)' : '' }}
                                                </option>
                                            </select>
                                        </div>
                                        <div class="col-span-2 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">ä½¿ç”¨æ­¦å™¨ (2)</label>
                                            <select v-model="currentRoundData.assassinations[char.id].weapon2" :disabled="!currentRoundData.assassinations[char.id].target2 || isDeadBeforeCurrentRound(char)" class="w-full border rounded px-2 py-2 bg-white disabled:bg-slate-100 text-sm">
                                                <option value="">-- é€‰æ‹©æ­¦å™¨ --</option>
                                                <option v-for="item in allFoundWeapons" :key="item" :value="item" :disabled="!isWeaponAvailable(item, char.id)">
                                                    {{ item }} {{ !isWeaponAvailable(item, char.id) ? '(å·²è¢«ä»–äººä½¿ç”¨)' : '' }}
                                                </option>
                                            </select>
                                        </div>
                                        <div class="col-span-1 md:col-span-3">
                                            <label class="block text-xs text-slate-500 mb-1">ç›®æ ‡é˜²å…· (2)</label>
                                            <select v-if="currentRoundData.assassinations[char.id].target2" v-model="currentRoundData.assassinations[char.id].target2Armor" class="w-full border rounded px-1 py-2 bg-white text-sm">
                                                <option value="">-- æ— é˜²å…· --</option>
                                                <optgroup label="å…æ­»é˜²å…·">
                                                    <option v-for="armor in allFoundArmors.lifeSaving" :key="armor" :value="armor" :disabled="!isArmorAvailable(armor, char.id, 2)">
                                                        {{ armor }} {{ !isArmorAvailable(armor, char.id, 2) ? '(å·²ç”¨)' : '' }}
                                                    </option>
                                                </optgroup>
                                                <optgroup label="é˜²ä¼¤é˜²å…·">
                                                    <option v-for="armor in allFoundArmors.damagePreventing" :key="armor" :value="armor" :disabled="!isArmorAvailable(armor, char.id, 2)">
                                                        {{ armor }} {{ !isArmorAvailable(armor, char.id, 2) ? '(å·²ç”¨)' : '' }}
                                                    </option>
                                                </optgroup>
                                            </select>
                                            <div v-else class="h-9 flex items-center text-slate-400 text-sm px-2">-</div>
                                        </div>
                                        <div class="col-span-1 md:col-span-3 flex justify-end md:justify-center items-center h-9">
                                            <span v-if="currentRoundData.assassinations[char.id].target2 && currentRoundData.assassinations[char.id].weapon2">
                                                <span v-if="!checkAssassinationResult(currentRoundData.assassinations[char.id].weapon2, currentRoundData.assassinations[char.id].target2Armor)" class="text-blue-600 font-bold bg-blue-50 px-3 py-1 rounded">ğŸ›¡ï¸ é˜²å¾¡</span>
                                                <span v-else class="text-red-600 font-bold bg-red-50 px-3 py-1 rounded">ğŸ’€ å‡»æ€</span>
                                            </span>
                                        </div>
                                    </div>
                                    
                                </div>
                            </div>
                            
                            <p class="text-right text-xs text-red-500 mt-2">* æ‰€æœ‰æš—æ€è¡Œä¸ºä¸é˜²å…·åˆ¤å®šå‡ä¼šå®æ—¶è‡ªåŠ¨ç»“ç®—ï¼Œæ— éœ€æ‰‹åŠ¨ç‚¹å‡»ã€‚</p>
                        </div>

                    </div>
                </div>

                <!-- Tab: Dashboard -->
                <div v-else-if="currentTab === 'dashboard'" key="dashboard" class="space-y-6">
                    <h2 class="text-xl font-bold border-b pb-2 text-indigo-700 flex justify-between items-center">
                        <span>ğŸ“Š çŠ¶æ€æ€»è§ˆ</span>
                        <button @click="resetGame" class="text-sm bg-slate-200 text-slate-700 px-3 py-1 rounded hover:bg-slate-300 transition-colors">é‡ç½®å…¨ç›˜æ¸¸æˆ</button>
                    </h2>

                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div v-for="char in characters" :key="char.id" 
                             class="border rounded-xl p-5 shadow-sm relative overflow-hidden transition-all"
                             :class="char.isAlive ? 'bg-white border-green-200' : 'bg-slate-100 border-red-200'">
                            
                            <!-- å­˜æ´»çŠ¶æ€è§’æ ‡ -->
                            <div v-if="char.isAlive" class="absolute top-0 right-0 bg-green-500 text-white text-xs font-bold px-3 py-1 rounded-bl-lg">å­˜æ´»</div>
                            <div v-else class="absolute top-0 right-0 bg-red-500 text-white text-xs font-bold px-3 py-1 rounded-bl-lg">æ­»äº¡</div>

                            <h3 class="font-bold text-xl mb-1 flex items-center gap-2">
                                <span>{{ char.name }}</span>
                                <span v-if="!char.isAlive" class="text-xl">ğŸ‘»</span>
                            </h3>
                            <p class="text-xs text-slate-500 mb-4 border-b pb-2">æœ€åç»“ç®—äºç¬¬ {{ char.lastUpdateRound || 0 }} è½®</p>

                            <div class="space-y-3">
                                <div>
                                    <h4 class="text-sm font-semibold text-slate-700 mb-1 flex items-center gap-1">ğŸ’ æŒæœ‰ç‰©å“ (æœè¯ç´¯ç§¯)</h4>
                                    <div class="flex flex-wrap gap-1">
                                        <span v-for="(item, idx) in calculateCharacterItems(char.id)" :key="idx" class="bg-indigo-100 text-indigo-800 text-xs px-2 py-1 rounded border border-indigo-200">
                                            {{ item }}
                                        </span>
                                        <span v-if="calculateCharacterItems(char.id).length === 0" class="text-sm text-slate-400">æš‚æ— ç‰©å“</span>
                                    </div>
                                </div>
                                
                                <div>
                                    <h4 class="text-sm font-semibold text-slate-700 mb-1 flex items-center gap-1">ğŸ“ æœè¯è½¨è¿¹</h4>
                                    <div class="text-sm text-slate-600 leading-relaxed">
                                        <div v-for="r in rounds" :key="r.id">
                                            <span v-if="r.searches[char.id] && r.searches[char.id].location" class="block">
                                                <span class="text-xs font-bold text-slate-400">R{{ r.id }}:</span>å‰å¾€ [{{ r.searches[char.id].location }}]
                                            </span>
                                        </div>
                                        <span v-if="rounds.every(r => !r.searches[char.id] || !r.searches[char.id].location)" class="text-slate-400">æ— æœè¯è®°å½•</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </transition>
        </main>
    </div>

    <script>
        const { createApp, ref, computed, reactive, watch, onMounted } = Vue;

        createApp({
            setup() {
                // UI çŠ¶æ€
                const currentTab = ref('setup');

                // åŸºç¡€æ•°æ®
                const characters = ref([]);
                const nextCharId = ref(1);
                const newCharacterName = ref('');

                const locations = ref([]);
                const newLocationName = ref('');

                const treasures = ref({}); // { 'åœ°ç‚¹': { up: 'ç‰©å“1', down: 'ç‰©å“2' } }

                // è½®æ¬¡æ•°æ®
                const rounds = ref([]);
                const currentRoundNumber = ref(1);

                // --- æœ¬åœ°å­˜å‚¨é€»è¾‘ (é¡µé¢åˆ·æ–°ä¸ä¸¢æ•°æ®) ---
                const saveData = () => {
                    const data = {
                        characters: characters.value,
                        nextCharId: nextCharId.value,
                        locations: locations.value,
                        treasures: treasures.value,
                        rounds: rounds.value,
                        currentRoundNumber: currentRoundNumber.value
                    };
                    localStorage.setItem('qinglou_data_v14', JSON.stringify(data));
                };

                const loadData = () => {
                    const data = localStorage.getItem('qinglou_data_v14');
                    if (data) {
                        try {
                            const parsed = JSON.parse(data);
                            characters.value = parsed.characters || [];
                            nextCharId.value = parsed.nextCharId || 1;
                            locations.value = parsed.locations || [];
                            treasures.value = parsed.treasures || {};
                            rounds.value = parsed.rounds || [];
                            currentRoundNumber.value = parsed.currentRoundNumber || 1;
                        } catch (e) {
                            console.error('Failed to parse local storage data');
                        }
                    } else {
                        // åˆå§‹é»˜è®¤æ•°æ®
                        characters.value = [
                            { id: 1, name: 'é™ˆä¸€å…”', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: 'æœˆå…”', maxSearches: 1, maxAssassinations: 1, extraLife: 0 },
                            { id: 2, name: 'å§œçº¢å„¿', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: '', maxSearches: 1, maxAssassinations: 1, extraLife: 0 },
                            { id: 3, name: 'è«æ€€', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: 'é€ç‰å‰‘', maxSearches: 1, maxAssassinations: 1, extraLife: 0 },
                            { id: 4, name: 'èˆ’æ‚¦', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: 'ç´«èè£³', maxSearches: 1, maxAssassinations: 1, extraLife: 0 },
                            { id: 5, name: 'ç™½æ–‹å­', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: '', maxSearches: 1, maxAssassinations: 1, extraLife: 0 },
                            { id: 6, name: 'é½å‰‘å¿ƒ', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: '', maxSearches: 1, maxAssassinations: 2, extraLife: 1 },
                            { id: 7, name: 'æœéœ„å…ƒ', isAlive: true, deathRound: null, lastUpdateRound: 0, initialItems: '', maxSearches: 2, maxAssassinations: 1, extraLife: 0 }
                        ];
                        nextCharId.value = 8;
                        locations.value = ['å¤§ç‰¢ä¸€', 'å¤§ç‰¢äºŒ', 'å¤§ç‰¢ä¸‰', 'å¤§ç‰¢å››', 'å¤§ç‰¢äº”', 'å¤§ç‰¢å…­', 'å¢™å£ä¸€', 'å¢™å£äºŒ', 'çµçŸ³', 'ç›‘ç‹±å…¥å£'];
                        const defaultTreasures = {
                            'å¤§ç‰¢ä¸€': { up: 'é“¶ä¸¤200', down: 'é“¶å‰‘' },
                            'å¤§ç‰¢äºŒ': { up: 'ç¢§éœè¡£', down: 'é“¶ä¸¤200' },
                            'å¤§ç‰¢ä¸‰': { up: 'é‡‘å‰‘', down: 'æœ¨è¡£' },
                            'å¤§ç‰¢å››': { up: 'é“¶ä¸¤200', down: 'äº”æœæœ' },
                            'å¤§ç‰¢äº”': { up: 'æ°´è¡£', down: 'åœŸè¡£' },
                            'å¤§ç‰¢å…­': { up: 'é“¶ä¸¤200', down: 'é“¶ä¸¤200' },
                            'å¢™å£ä¸€': { up: 'é“¶ä¸¤200', down: 'ç”µè¡£' },
                            'å¢™å£äºŒ': { up: 'æ··å…ƒå‰‘', down: 'é“¶ä¸¤200' },
                            'çµçŸ³': { up: 'é“¶ä¸¤200', down: 'é‡‘è¡£' },
                            'ç›‘ç‹±å…¥å£': { up: 'ç«è¡£', down: 'é“¶ä¸¤200' }
                        };
                        locations.value.forEach(loc => { treasures.value[loc] = defaultTreasures[loc] || { up: '', down: '' }; });
                        initRound(1);
                    }
                };

                // åœ¨ç»„ä»¶æŒ‚è½½æ—¶è¯»å–æ•°æ®
                onMounted(() => {
                    loadData();
                });

                // ---------------------------------

                // --- åŸºç¡€è®¾ç½®é€»è¾‘ ---
                const addCharacter = () => {
                    if (newCharacterName.value.trim()) {
                        characters.value.push({
                            id: nextCharId.value++,
                            name: newCharacterName.value.trim(),
                            isAlive: true,
                            deathRound: null,
                            lastUpdateRound: 0,
                            initialItems: '',
                            maxSearches: 1,
                            maxAssassinations: 1,
                            extraLife: 0
                        });
                        newCharacterName.value = '';
                        ensureRoundDataStructures();
                    }
                };
                const removeCharacter = (index) => {
                    if (confirm('ç¡®å®šåˆ é™¤è¯¥è§’è‰²å—ï¼Ÿä¼šå½±å“å†å²è½®æ¬¡è®°å½•ï¼')) {
                        characters.value.splice(index, 1);
                    }
                };

                const addLocation = () => {
                    const loc = newLocationName.value.trim();
                    if (loc && !locations.value.includes(loc)) {
                        locations.value.push(loc);
                        treasures.value[loc] = { up: '', down: '' };
                        newLocationName.value = '';
                    }
                };
                const removeLocation = (index) => {
                    const loc = locations.value[index];
                    if (confirm(`ç¡®å®šåˆ é™¤åœ°ç‚¹ "${loc}" å—ï¼Ÿè¿™ä¼šæ¸…é™¤è¯¥åœ°ç‚¹çš„å®è—è®°å½•ã€‚`)) {
                        locations.value.splice(index, 1);
                        delete treasures.value[loc];
                    }
                };

                // --- å®è—è®¾ç½®é€»è¾‘ ---
                // (ç›´æ¥ä½¿ç”¨v-modelç»‘å®š)

                // --- è½®æ¬¡é€»è¾‘ ---
                const initRound = (roundNum) => {
                    const existingRound = rounds.value.find(r => r.id === roundNum);
                    if (!existingRound) {
                        const newRound = { id: roundNum, searches: {}, assassinations: {}, settled: false };
                        characters.value.forEach(c => {
                            newRound.searches[c.id] = { location: '', items: '', location2: '', items2: '' };
                            newRound.assassinations[c.id] = { target: '', weapon: '', targetHasArmor: false, target2: '', weapon2: '', target2HasArmor: false };
                        });
                        rounds.value.push(newRound);
                    }
                };

                const ensureRoundDataStructures = () => {
                    rounds.value.forEach(round => {
                        characters.value.forEach(c => {
                            if (!round.searches[c.id]) {
                                round.searches[c.id] = { location: '', items: '', location2: '', items2: '' };
                            } else if (round.searches[c.id].location2 === undefined) {
                                round.searches[c.id].location2 = '';
                                round.searches[c.id].items2 = '';
                            }
                            if (!round.assassinations[c.id]) {
                                round.assassinations[c.id] = { target: '', weapon: '', targetArmor: '', target2: '', weapon2: '', target2Armor: '' };
                            } else {
                                if (round.assassinations[c.id].weapon === undefined) round.assassinations[c.id].weapon = '';
                                if (round.assassinations[c.id].targetArmor === undefined) round.assassinations[c.id].targetArmor = '';
                                if (round.assassinations[c.id].target2 === undefined) {
                                    round.assassinations[c.id].target2 = '';
                                    round.assassinations[c.id].weapon2 = '';
                                    round.assassinations[c.id].target2Armor = '';
                                }
                                if (round.assassinations[c.id].target2Armor === undefined) round.assassinations[c.id].target2Armor = '';
                            }
                        });
                    });
                };

                const prevRound = () => {
                    if (currentRoundNumber.value > 1) {
                        currentRoundNumber.value--;
                    }
                };

                const nextRound = () => {
                    currentRoundNumber.value++;
                    initRound(currentRoundNumber.value);
                };

                const currentRoundData = computed(() => {
                    let round = rounds.value.find(r => r.id === currentRoundNumber.value);
                    if (!round) {
                        // é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œä¸åº”è¯¥å‘ç”Ÿ
                        initRound(currentRoundNumber.value);
                        round = rounds.value.find(r => r.id === currentRoundNumber.value);
                    }
                    return round;
                });

                // --- è‡ªåŠ¨ç»“ç®—é€»è¾‘ ---
                const lifeSavingArmors = ['æœˆå…”', 'ç´«èè£³', 'å½¼å²¸èŠ±', 'ç¢§éœè¡£', 'äº”æœæœ'];
                const damagePreventingArmors = ['é‡‘è¡£', 'æœ¨è¡£', 'æ°´è¡£', 'ç«è¡£', 'åœŸè¡£', 'ç”µè¡£', 'é£è¡£', 'é›·è¡£'];
                const fatalWeapons = ['é€ç‰å‰‘', 'æ··å…ƒå‰‘'];
                const damagingWeapons = ['é‡‘å‰‘', 'é“¶å‰‘', 'é“œå‰‘'];
                
                const getItemCostText = (itemsString) => {
                    if (!itemsString) return '-';
                    const items = itemsString.split(/[,ï¼Œ]/).map(i => i.trim());
                    let maxCost = 0;
                    for (let item of items) {
                        if (fatalWeapons.includes(item)) maxCost = Math.max(maxCost, 2000);
                        else if (lifeSavingArmors.includes(item)) maxCost = Math.max(maxCost, 1000);
                        else if (damagingWeapons.includes(item)) maxCost = Math.max(maxCost, 700);
                        else if (damagePreventingArmors.includes(item)) maxCost = Math.max(maxCost, 500);
                    }
                    return maxCost > 0 ? maxCost + ' é“¶ä¸¤' : '-';
                };
                
                const checkAssassinationResult = (weapon, armor) => {
                    if (!weapon) return false; // æ²¡æ­¦å™¨æ€ä¸äº†äºº
                    if (!armor) return true; // æ²¡é˜²å…·å¿…æ­»
                    if (lifeSavingArmors.includes(armor)) return false; // å…æ­»é˜²å…·æŒ¡ä¸€åˆ‡(æˆ–è€…è‡³å°‘æŒ¡è‡´å‘½å’Œè‡´ä¼¤)
                    if (fatalWeapons.includes(weapon) && damagePreventingArmors.includes(armor)) return true; // é˜²ä¼¤é˜²å…·æŒ¡ä¸ä½è‡´å‘½æ­¦å™¨
                    if (damagePreventingArmors.includes(armor)) return false; // é˜²ä¼¤é˜²å…·æŒ¡ä½è‡´ä¼¤æ­¦å™¨
                    return true;
                };

                const autoSettle = () => {
                    let statusMap = {};
                    characters.value.forEach(c => {
                        statusMap[c.id] = { isAlive: true, deathRound: null, lastUpdateRound: 0, extraLife: c.extraLife || 0 };
                    });

                    rounds.value.forEach(round => {
                        Object.entries(round.assassinations).forEach(([actorId, action]) => {
                            const processTarget = (targetId, weapon, armor) => {
                                if (targetId && weapon) {
                                    const targetStatus = statusMap[targetId];
                                    const isKilled = checkAssassinationResult(weapon, armor);
                                    if (targetStatus && targetStatus.isAlive && isKilled) {
                                        if (targetStatus.extraLife > 0) {
                                            targetStatus.extraLife--;
                                            targetStatus.lastUpdateRound = round.id;
                                        } else {
                                            targetStatus.isAlive = false;
                                            targetStatus.deathRound = round.id;
                                            targetStatus.lastUpdateRound = round.id;
                                        }
                                    }
                                }
                            };
                            processTarget(action.target, action.weapon, action.targetArmor);
                            processTarget(action.target2, action.weapon2, action.target2Armor);
                        });

                        characters.value.forEach(c => {
                            if (round.searches[c.id]?.location || round.searches[c.id]?.items || 
                                round.searches[c.id]?.location2 || round.searches[c.id]?.items2 ||
                                round.assassinations[c.id]?.target || round.assassinations[c.id]?.target2) {
                                if (statusMap[c.id].lastUpdateRound < round.id) {
                                    statusMap[c.id].lastUpdateRound = round.id;
                                }
                            }
                        });
                    });

                    characters.value.forEach(c => {
                        const s = statusMap[c.id];
                        if (c.isAlive !== s.isAlive) c.isAlive = s.isAlive;
                        if (c.deathRound !== s.deathRound) c.deathRound = s.deathRound;
                        if (c.lastUpdateRound !== s.lastUpdateRound) c.lastUpdateRound = s.lastUpdateRound;
                    });
                };

                // --- çŠ¶æ€è®¡ç®— ---
                const calculateCharacterItems = (charId) => {
                    let itemsList = [];
                    const char = characters.value.find(c => c.id === charId);
                    if (char && char.initialItems) {
                        itemsList.push(...char.initialItems.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i));
                    }
                    // éå†æ‰€æœ‰è½®æ¬¡ç´¯åŠ è¯¥è§’è‰²çš„ç‰©å“
                    rounds.value.forEach(r => {
                        const searchRecord = r.searches[charId];
                        if (searchRecord && searchRecord.items) {
                            const items = searchRecord.items.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i);
                            itemsList.push(...items);
                        }
                        if (searchRecord && searchRecord.items2) {
                            const items2 = searchRecord.items2.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i);
                            itemsList.push(...items2);
                        }
                    });
                    return itemsList;
                };

                // --- é˜²å…·ä¸ç‰©å“å¯ç”¨æ€§é€»è¾‘ ---
                const isWeaponAvailable = (weaponName, charId) => {
                    if (!weaponName) return false;
                    const round = currentRoundData.value;
                    for (let c of characters.value) {
                        if (c.id !== charId) {
                            if (round.assassinations[c.id]?.weapon === weaponName) return false;
                            if (round.assassinations[c.id]?.weapon2 === weaponName) return false;
                        }
                    }
                    return true;
                };

                const isArmorAvailable = (armorName, checkCharId, checkActionIndex) => {
                    if (!armorName) return false;
                    
                    for (let r of rounds.value) {
                        for (let c of characters.value) {
                            if (r.assassinations[c.id]?.targetArmor === armorName) {
                                // å¦‚æœæ˜¯æ­£åœ¨æ£€æŸ¥çš„è¿™ä¸ªä¸‹æ‹‰æ¡†æŒæœ‰çš„ï¼Œåˆ™å¯ç”¨
                                if (r.id === currentRoundNumber.value && c.id === checkCharId && checkActionIndex === 1) return true;
                                return false;
                            }
                            if (r.assassinations[c.id]?.target2Armor === armorName) {
                                // å¦‚æœæ˜¯æ­£åœ¨æ£€æŸ¥çš„è¿™ä¸ªä¸‹æ‹‰æ¡†æŒæœ‰çš„ï¼Œåˆ™å¯ç”¨
                                if (r.id === currentRoundNumber.value && c.id === checkCharId && checkActionIndex === 2) return true;
                                return false;
                            }
                        }
                    }
                    return true;
                };

                // --- æœè¯è‡ªåŠ¨å¡«å……é€»è¾‘ ---
                const isDeadBeforeCurrentRound = (char) => {
                    return char.deathRound !== null && char.deathRound < currentRoundNumber.value;
                };

                const isItemAvailable = (locSelection, checkRoundNum, checkCharId, checkSearchIndex) => {
                    if (!locSelection) return false;
                    
                    // æ£€æŸ¥ä¹‹å‰çš„è½®æ¬¡
                    for (let r of rounds.value) {
                        if (r.id < checkRoundNum) {
                            for (let c of characters.value) {
                                if (r.searches[c.id]?.location === locSelection) return false;
                                if (r.searches[c.id]?.location2 === locSelection) return false;
                            }
                        } else if (r.id === checkRoundNum) {
                            // æ£€æŸ¥å½“å‰è½®æ¬¡ä¸­æ’åœ¨ checkCharId å‰é¢çš„äºº
                            for (let c of characters.value) {
                                if (c.id === checkCharId) {
                                    // åˆ°è‡ªå·±äº†ï¼Œå¦‚æœæ˜¯ç¬¬äºŒæ¬¡æœç´¢ï¼Œè¿˜è¦æ£€æŸ¥è‡ªå·±çš„ç¬¬ä¸€æ¬¡æœç´¢
                                    if (checkSearchIndex === 2 && r.searches[c.id]?.location === locSelection) return false;
                                    break;
                                }
                                if (r.searches[c.id]?.location === locSelection) return false;
                                if (r.searches[c.id]?.location2 === locSelection) return false;
                            }
                        }
                    }
                    return true;
                };

                const getAvailableItemText = (locSelection, charId, searchIndex = 1) => {
                    if (!locSelection) return 'ç©º';
                    const [loc, pos] = locSelection.split(' - ');
                    const item = pos === 'ä¸Š' ? treasures.value[loc]?.up : treasures.value[loc]?.down;
                    if (!item) return 'ç©º';
                    
                    if (isItemAvailable(locSelection, currentRoundNumber.value, charId, searchIndex)) {
                        return item;
                    } else {
                        return 'å·²ç©º';
                    }
                };

                const onSearchLocationChange = (charId, searchIndex = 1) => {
                    const locSelection = searchIndex === 1 ? currentRoundData.value.searches[charId].location : currentRoundData.value.searches[charId].location2;
                    if (locSelection) {
                        if (isItemAvailable(locSelection, currentRoundNumber.value, charId, searchIndex)) {
                            const [loc, pos] = locSelection.split(' - ');
                            if (loc && pos) {
                                const item = pos === 'ä¸Š' ? treasures.value[loc]?.up : treasures.value[loc]?.down;
                                if (item) {
                                    // è‡ªåŠ¨å¸¦å…¥ç‰©å“ï¼Œå¦‚æœåŸæ¥å·²ç»æœ‰å€¼äº†å¯ä»¥åŠ é€—å·
                                    const currentItems = searchIndex === 1 ? currentRoundData.value.searches[charId].items : currentRoundData.value.searches[charId].items2;
                                    if (!currentItems) {
                                        if (searchIndex === 1) currentRoundData.value.searches[charId].items = item;
                                        else currentRoundData.value.searches[charId].items2 = item;
                                    } else if (!currentItems.includes(item)) {
                                        if (searchIndex === 1) currentRoundData.value.searches[charId].items = currentItems + ', ' + item;
                                        else currentRoundData.value.searches[charId].items2 = currentItems + ', ' + item;
                                    }
                                }
                            }
                        }
                    }
                };

                const allFoundItems = computed(() => {
                    let itemsSet = new Set(['å½¼å²¸èŠ±']); // å°†NPCæŒæœ‰çš„å½¼å²¸èŠ±é»˜è®¤åŠ å…¥å…¨å±€æ± 
                    characters.value.forEach(c => {
                        if (c.initialItems) {
                            c.initialItems.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i).forEach(i => itemsSet.add(i));
                        }
                    });
                    rounds.value.forEach(r => {
                        if (r.id <= currentRoundNumber.value) {
                            characters.value.forEach(c => {
                                const searchRecord = r.searches[c.id];
                                if (searchRecord && searchRecord.items) {
                                    const items = searchRecord.items.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i);
                                    items.forEach(i => itemsSet.add(i));
                                }
                                if (searchRecord && searchRecord.items2) {
                                    const items2 = searchRecord.items2.split(/[,ï¼Œ]/).map(i => i.trim()).filter(i => i);
                                    items2.forEach(i => itemsSet.add(i));
                                }
                            });
                        }
                    });
                    return Array.from(itemsSet);
                });

                const allFoundWeapons = computed(() => {
                    return allFoundItems.value.filter(item => item.includes('å‰‘'));
                });

                const allFoundArmors = computed(() => {
                    return {
                        lifeSaving: allFoundItems.value.filter(item => lifeSavingArmors.includes(item)),
                        damagePreventing: allFoundItems.value.filter(item => damagePreventingArmors.includes(item))
                    };
                });

                // --- é‡ç½®æ¸¸æˆ ---
                const resetGame = () => {
                    if (confirm('ã€å±é™©æ“ä½œã€‘ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ¸¸æˆæ•°æ®ï¼ˆåŒ…æ‹¬æ‰€æœ‰è½®æ¬¡ã€æ‰€æœ‰è§’è‰²ã€æ‰€æœ‰å®è—è®¾ç½®ï¼‰å—ï¼Ÿä¸å¯æ¢å¤ï¼')) {
                        localStorage.removeItem('qinglou_data_v14');
                        location.reload();
                    }
                }

                // æ·±åº¦ç›‘å¬æ‰€æœ‰æ ¸å¿ƒæ•°æ®å˜åŒ–ï¼Œä¿å­˜åˆ° localStorage
                watch([characters, locations, treasures, rounds, currentRoundNumber], () => {
                    autoSettle();
                    saveData();
                }, { deep: true });

                return {
                    currentTab,
                    characters, newCharacterName, addCharacter, removeCharacter,
                    locations, newLocationName, addLocation, removeLocation,
                    treasures, 
                    rounds, currentRoundNumber, prevRound, nextRound, currentRoundData,
                    onSearchLocationChange, getAvailableItemText, isDeadBeforeCurrentRound,
                    calculateCharacterItems, resetGame, allFoundItems, allFoundWeapons, allFoundArmors, checkAssassinationResult, isArmorAvailable, isWeaponAvailable, getItemCostText
                };
            }
        }).mount('#app');
    </script>
</body>
</html>